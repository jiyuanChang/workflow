## **Sogou C++ Workflow**

[![License](https://img.shields.io/badge/License-Apache%202.0-green.svg)](https://github.com/sogou/workflow/blob/master/LICENSE)
[![Language](https://img.shields.io/badge/language-c++-red.svg)](https://en.cppreference.com/) 
[![Platform](https://img.shields.io/badge/platform-linux%20%7C%20macos%20%7C%20windows-lightgrey.svg)](https://img.shields.io/badge/platform-linux%20%7C%20macos20%7C%20windows-lightgrey.svg)
[![Build Status](https://img.shields.io/github/workflow/status/sogou/workflow/ci%20build)](https://github.com/sogou/workflow/actions?query=workflow%3A%22ci+build%22++)

В качестве серверного движка **Sogou C++ Workflow** поддерживает практически все **серверные C++ онлайн-сервисы** Sogou, включая все поисковые сервисы, облачный метод ввода, онлайн-рекламу и т.д., обрабатывая более 10 миллиардов запросов каждый день. Это **программный движок корпоративного уровня** в легком и элегантном дизайне, который может удовлетворить большинство требований к серверной разработке на C++. This is an programming engine which can satisfy most C++ back-end development requirements.



#### **Вы можете воспользоваться им:**

* Начало работы для быстрого создания **HTTP-сервера**:

  ``` c++
  #include <stdio.h>
  #include "workflow/WFHttpServer.h"
  
  int main()
  {
      WFHttpServer server([](WFHttpTask *task) {
          task->get_resp()->append_output_body("<html>Hello World!</html>");
      });
  
      if (server.start(8888) == 0) { // start server on port 8888
          getchar(); // press "Enter" to end.
          server.stop();
      }
  
      return 0;
  }
  ```

* В качестве **многофункционального асинхронного клиента**, он поддерживает поддерживает протоколы ``` HTTP```, ``` Redis```, ``` MySQL``` и ```Kafka``` в настоящее время.

* Вы можете реализовать **клиент/сервер по определяемому пользователем протоколу** и создать свою **RPС систему**.

  	+ [srpc](https://github.com/sogou/srpc) основан на нем и является независимым проектом с открытым исходным кодом, который поддерживает протоколы srpc, brpc, trpc и thrift.   

* Для построения **asynchronous workflows**; Поддержка общих **последовательно- параллельных** структур, а также поддержка любых структур **DAG**.

* **Инструмент для параллельных вычислений** - В дополнение к **сетевым задачам** рабочий процесс Sogou C++ также включает в себя **планирование вычислительных задач**. Все типы задач могут быть объединены **в один и тот же поток**.

* **Инструмент асинхронного ввода-вывода файлов** в системе ``` Linux``` - Кго высокая производительность превосходит любой системный вызов. Ввод-вывод дисковых файлов также является задачей.

* Для реализации любого **высокопроизводительного** и **высококонкурентного** серверного сервиса с очень сложной взаимосвязью между вычислениями и сетями. 

* Для построения **микросервисной системы**.

     * Этот проект имеет встроенные характически - **service governance** и **load balancing**.

* Сыллка Wiki: [PaaS Architecture](https://github.com/sogou/workflow/wiki)

​	

#### **Системные требования:**

* Этот проект поддерживает ``` Linux```, ```macOS```, ```Windows```, ```Android``` и другие операционные системы.

  * Версия ```Windows ``` в настоящее время выпущена как независимая [ветвь](https://github.com/sogou/workflow/tree/windows), использующая ```iocp ``` для реализации асинхронной сети. Все пользовательские интерфейсы соответствуют версии ```Linux```.

* Workflow может работать на любой платформе процессоров, включая 32-бит или 64-бит процессоры ```x86```, процессоры arm на маленьком конце(little-endian) или на большом(big-endian), процессоры ```loongson```.

* Workflow основан на ```OpenSSL```; Команда Sogou C++ Workflow рекомендует использовать ```OpenSSL 1.1``` и выше. 

  * Если вам не нравится SSL, вы можете проверить ветку [nossl](https://github.com/sogou/workflow/tree/nossl). Но еще нужно связать ```crypto ```для ```md5``` и ```sha1```.

* Этот проект использует стандарт ```C++11```, и поэтому он должен быть скомпилирован с помощью компилятора, поддерживающего ```C++11```. Не полагается на ```boost ``` или ```asio```.

* Никаких других зависимостей. Eсли вам нужен протокол ```Kafka```, необходимо установить некоторые библиотеки сжатия, включая ```lz4```, ```zstd ``` и ```snappy```.



### **Установка (Linux, macOS):**

``` git
git clone https://github.com/sogou/workflow
cd workflow
make
cd tutorial
make
```



### Установка (Debian Linux, ubuntu 22.04): 

Sogou C++ Workflow был упакован для Debian Linux и ubuntu 22.04. Для установки пакетов выполните:

``` Linux command line
sudo apt-get install libworkflow-dev
```

### Среда выполнения развертывания: 

``` Linux command line
sudo apt-get install libworkflow1
```

Обратите внимание, что только последняя версия Ubuntu Linux 22.04 поставляется с workflow. Рекомендуется использовать git для прямой загрузки последнего исходного кода для компиляции.

# **Практические руководства**

* Клиент

  * [Создание вашей первой задачи: wget](docs/en/tutorial-01-wget.md)

  * [Реализация Redis set и get: redis_cli](docs/en/tutorial-02-redis_cli.md)

  * [Больше характеристики о серии: get_to_redis](docs/en/tutorial-03-wget_to_redis.md)

* Сервер

  * [Первый сервер: http_echo_server](docs/en/tutorial-04-http_echo_server.md)

  * [Асинхронный сервер: http_proxy](docs/en/tutorial-05-http_proxy.md)

* Параллельные задачи и серии

  * [Одная простая параллель wget: parallel_wget](docs/en/tutorial-06-parallel_wget.md)

* Важные темы

  * [Об обработке ошибок](docs/en/about-error.md)

  * [О тайм-ауте](docs/en/about-timeout.md)

  * [О глобальной конфигурации](docs/en/about-config.md)

  * [О DNS](docs/en/about-dns.md)

  * [О выходе](docs/en/about-exit.md)

* Вычислительные задачи

  * [Использование встроенной фабрики алгоритмов: sort_task](docs/en/tutorial-07-sort_task.md)

  * [Пользовательская вычислительная задача: matrix_multiply](docs/en/tutorial-08-matrix_multiply.md)

  * [Вычислительная задача простым способом: go task](docs/en/about-go-task.md) [Рекомендация]

* Асинхронные задачи ввода-вывода файлов

  * [Http-сервер с файловым вводом-выводом: http_file_server](docs/en/tutorial-09-http_file_server.md)

* Определяемый пользователем протокол

  * [Простой определяемый пользовательский протокол: клиент/сервер](docs/en/tutorial-10-user_defined_protocol.md)

* Временные задачи и подсчет задач

  * [О таймере](https://github.com/sogou/workflow/blob/master/docs/en/about-timer.md)

  * [О счетчике](https://github.com/sogou/workflow/blob/master/docs/en/about-counter.md)

  * [О пуле ресурсов](https://github.com/sogou/workflow/blob/master/docs/en/about-resource-pool.md)

  * [О модуле](https://github.com/sogou/workflow/blob/master/docs/en/about-module.md)

* Service governance

  * [Об service governance](docs/en/about-service-governance.md)

  * [Дополнительные документы о upstream](docs/en/about-upstream.md)

* Контекст подключения

  * [О контексте подключения](docs/en/about-connection-context.md)

* Встроенные клиенты

  * [Асинхронный клиент MySQL: mysql_client](docs/en/tutorial-12-mysql_cli.md)

  * [Асинхронный клиент Kafka: kafka_cli](docs/en/tutorial-13-kafka_cli.md)

#### Парадигма программирования

Мы верим в типичный серверный - Программа = Протокол + Алгоритм + Рабочий процесс.

* Протокол

  * В большинстве случаев пользователи используют встроенные общие сетевые протоколы, такие как HTTP, Redis или различные rpc.
  * Пользователи также могут легко настраивать определяемый пользователем сетевой протокол. При настройке им нужно только предоставить функции сериализации и десериализации, чтобы определить свой собственный клиент / сервер.

* Алгоритм

  * В нашем дизайне алгоритм представляет собой концепцию, симметричную протоколу.
    * Если вызов протокола - rpc, то вызов алгоритма - это apc. (Асинхронный Вызов процедуры)
  * Мы предоставили некоторые общие алгоритмы, такие как sort, merge, psort, reduce, которые можно использовать непосредственно.
  * По сравнению с определяемым пользователем протоколом, определяемый пользователем алгоритм является гораздо более распространенным. Любое сложное вычисление с четкими границами должно быть упаковано в алгоритм. Сложная бизнес-логика может быть незамкнутой DAG.

* Рабочий процесс

  * Рабочий процесс - это фактическая бизнес-логика, которая заключается в том, чтобы поместить протоколы и алгоритмы в потоковый график для использования.
  * Типичный рабочий процесс представляет собой замкнутый последовательно-параллельный граф.
  * График рабочего процесса может быть построен непосредственно или динамически сгенерирован на основе результатов каждого шага. Все задачи выполняются асинхронно.

Базовая задача, фабрика задач и сложная задача

* Наша система содержит шесть основных задач: сетевой, ввод-вывод файлов, ЦП, ГП, таймер and счетчик.
* Все задачи генерируются фабрикой задач и автоматически перерабатываются после обратного вызова.
  * Серверная задача - это один из видов специальной сетевой задачи, генерируемой фреймворком, который вызывает фабрику задач, и передается пользователю через функцию процесса.
* В большинстве случаев задача, сгенерированная пользователем с помощью фабрики задач, представляет собой сложную задачу, которая прозрачна для пользователя. 
  * Например, HTTP-запрос может включать в себя множество асинхронных процессов (DNS, перенаправление), но для пользователя это просто сетевая задача. 
  * Сортировка файлов кажется алгоритмом, но на самом деле она включает в себя множество сложных процессов взаимодействия между вводом-выводом файлов и вычислениями ЦП.
  * Если вы представляете бизнес-логику как построение схем с  спроектированными электронными компонентами, то каждый электронный компонент может представлять собой сложную схему.

Асинхронность и инкапсуляция на основе ```C++11 std::function```

* Не основано на сопрограммах пользовательского режима. Пользователи должны знать, что они пишут асинхронные программы.
* Все вызовы выполняются асинхронно, и почти нет операций, которые занимали бы поток выполнения.
  * Although we also provide some facilities with semi-synchronous interfaces, they are not core features.
* Мы стараемся избегать пользовательских производных и вместо этого инкапсулируем поведение пользователя с помощью ```std::function```, включая:
  * Обратный вызов любой задачи.
  * Любой серверный процесс. Это соответствует идее ```FaaS```(Function as a Service).
  * Реализация алгоритма - это просто ```std::функция```. Но это алгоритм также может быть реализован путем деривации.

Механизм сборки памяти

* Каждая задача будет автоматически переработан после обратного вызова. Если задача создана, но пользователь не хочет ее запускать, пользователю необходимо освободить ее с помощью метода dismiss.
* Любые данные в задаче, такие как ответ на сетевой запрос, также будут переработаны вместе с задачей. В это время пользователь может использовать ```std::move()``` для перемещения необходимых данных.
* SeriesWork и ParallelWork - это два вида объектов фреймворка, которые также перерабатываются после их обратного вызова. 
  * Когда серия является ветвью параллели, она будет переработана после обратного вызова параллели, к которой она принадлежит.
* Этот проект не использует ```std::shared_ptr``` для управления памятью.

#### **F.A.Q**

Вы можете сначала проверять списки [issues](https://github.com/sogou/workflow/issues) и [FAQ](https://github.com/sogou/workflow/issues/406), чтобы узнать, сможете ли вы найти ответ.

Пожалуйста, присылайте проблемы, с которыми вы сталкиваетесь при использовании, в issues, и мы ответим на них как можно скорее. В то же время больше проблемы также помогут новым пользователям.
